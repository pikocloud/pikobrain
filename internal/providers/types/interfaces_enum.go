// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package types

import (
	"database/sql/driver"
	"errors"
	"fmt"
)

const (
	// MIMEText is a MIME of type text.
	MIMEText MIME = "text/plain"
	// MIMEJson is a MIME of type json.
	MIMEJson MIME = "application/json"
	// MIMEPng is a MIME of type png.
	MIMEPng MIME = "image/png"
	// MIMEJpeg is a MIME of type jpeg.
	MIMEJpeg MIME = "image/jpeg"
	// MIMEJpg is a MIME of type jpg.
	MIMEJpg MIME = "image/jpg"
	// MIMEWebp is a MIME of type webp.
	MIMEWebp MIME = "image/webp"
	// MIMEGif is a MIME of type gif.
	MIMEGif MIME = "image/gif"
)

var ErrInvalidMIME = errors.New("not a valid MIME")

// MIMEValues returns a list of the values for MIME
func MIMEValues() []MIME {
	return []MIME{
		MIMEText,
		MIMEJson,
		MIMEPng,
		MIMEJpeg,
		MIMEJpg,
		MIMEWebp,
		MIMEGif,
	}
}

// String implements the Stringer interface.
func (x MIME) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x MIME) IsValid() bool {
	_, err := ParseMIME(string(x))
	return err == nil
}

var _MIMEValue = map[string]MIME{
	"text/plain":       MIMEText,
	"application/json": MIMEJson,
	"image/png":        MIMEPng,
	"image/jpeg":       MIMEJpeg,
	"image/jpg":        MIMEJpg,
	"image/webp":       MIMEWebp,
	"image/gif":        MIMEGif,
}

// ParseMIME attempts to convert a string to a MIME.
func ParseMIME(name string) (MIME, error) {
	if x, ok := _MIMEValue[name]; ok {
		return x, nil
	}
	return MIME(""), fmt.Errorf("%s is %w", name, ErrInvalidMIME)
}

var errMIMENilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *MIME) Scan(value interface{}) (err error) {
	if value == nil {
		*x = MIME("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseMIME(v)
	case []byte:
		*x, err = ParseMIME(string(v))
	case MIME:
		*x = v
	case *MIME:
		if v == nil {
			return errMIMENilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errMIMENilPtr
		}
		*x, err = ParseMIME(*v)
	default:
		return errors.New("invalid type for MIME")
	}

	return
}

// Value implements the driver Valuer interface.
func (x MIME) Value() (driver.Value, error) {
	return x.String(), nil
}

const (
	// RoleUser is a Role of type user.
	RoleUser Role = "user"
	// RoleAssistant is a Role of type assistant.
	RoleAssistant Role = "assistant"
	// RoleToolCall is a Role of type toolCall.
	RoleToolCall Role = "toolCall"
	// RoleToolResult is a Role of type toolResult.
	RoleToolResult Role = "toolResult"
)

var ErrInvalidRole = errors.New("not a valid Role")

// RoleValues returns a list of the values for Role
func RoleValues() []Role {
	return []Role{
		RoleUser,
		RoleAssistant,
		RoleToolCall,
		RoleToolResult,
	}
}

// String implements the Stringer interface.
func (x Role) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Role) IsValid() bool {
	_, err := ParseRole(string(x))
	return err == nil
}

var _RoleValue = map[string]Role{
	"user":       RoleUser,
	"assistant":  RoleAssistant,
	"toolCall":   RoleToolCall,
	"toolResult": RoleToolResult,
}

// ParseRole attempts to convert a string to a Role.
func ParseRole(name string) (Role, error) {
	if x, ok := _RoleValue[name]; ok {
		return x, nil
	}
	return Role(""), fmt.Errorf("%s is %w", name, ErrInvalidRole)
}

var errRoleNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *Role) Scan(value interface{}) (err error) {
	if value == nil {
		*x = Role("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseRole(v)
	case []byte:
		*x, err = ParseRole(string(v))
	case Role:
		*x = v
	case *Role:
		if v == nil {
			return errRoleNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errRoleNilPtr
		}
		*x, err = ParseRole(*v)
	default:
		return errors.New("invalid type for Role")
	}

	return
}

// Value implements the driver Valuer interface.
func (x Role) Value() (driver.Value, error) {
	return x.String(), nil
}
